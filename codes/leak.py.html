<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="color-scheme" content="light dark">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>leak.py</title>
  <link rel="stylesheet" href="../style/code.css">
  <link rel="stylesheet" href="../highlightjs/github.min.css" media="screen and (prefers-color-scheme: light)">
  <link rel="stylesheet" href="../highlightjs/github-dark.min.css" media="screen and (prefers-color-scheme: dark)">
  <script src="../highlightjs/highlight-python.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body>

<pre><code class="language-python">#!/usr/bin/env python
#
# leak.py
#
# A toy memory leak detector for ltrace
#
# This is a proof of concept work for detecting memory leaks from the output of
# ltrace. The idea is to simply trace malloc and free calls in an execution and
# report non-freed allocations in the end. Other allocation methods are not
# added to keep it simple.
#
# This can only detect the existence of leaks without showing the location of
# the allocations in the source code. Also, since this is a dynamic analysis
# method, absence of leaks does not necessarily mean the program is leak free
# for all execution paths. Therefore, this is not very useful in practice.
#
# To run the script, you need to redirect ltrace output from stderr to stdout,
# and then redirect regular output to null device, and pipe stdout to this
# script. An example for `ls` command is shown below:
#
#     ltrace ls 2&gt;&amp;1 &gt;/dev/null | ./leak.py
#

import re
import sys

lines = filter(lambda l: &apos;malloc&apos; in l or &apos;free&apos; in l, sys.stdin)

print &apos;\nThese are all the malloc and free calls in the execution&apos;
for line in lines:
    print line,

mems = {}
for line in lines:
    toks = line.split()

    # malloc(size) = addr
    if &apos;malloc&apos; in toks[0]:
        size = re.search(r&apos;malloc\((.*)\)&apos;, toks[0]).group(1)
        addr = toks[2]
        mems[addr] = size

    # free(addr) = &lt;void&gt;
    elif &apos;free&apos; in toks[0]:
        addr = re.search(r&apos;free\((.*)\)&apos;, toks[0]).group(1)
        mems.pop(addr, None)

print &apos;\nExecution ended with the following non-freed allocations&apos;
for k, v in mems.iteritems():
    print &apos;leaked&apos;, v, &apos;bytes of memory at&apos;, k
</code></pre>

</body>

</html>

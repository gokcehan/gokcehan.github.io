<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="color-scheme" content="light dark">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>pcap.py</title>
  <link rel="stylesheet" href="../style/code.css">
  <link rel="stylesheet" href="../highlightjs/github.min.css" media="screen and (prefers-color-scheme: light)">
  <link rel="stylesheet" href="../highlightjs/github-dark.min.css" media="screen and (prefers-color-scheme: dark)">
  <script src="../highlightjs/highlight-python.min.js"></script>
  <script>hljs.highlightAll();</script>
</head>

<body>

<pre><code class="language-python">#!/usr/bin/env python3
#
# pcap.py
#
# Pcap file decoder for the standard TCP/IP stack
#
# This is a basic decoder for TCP packets composed of IP and ETH packets within
# a pcap file. Other types of packets are simply denoted with &apos;UNK&apos; and are not
# decoded any further. This is used for post-mortem analysis of network traffic
# captured beforehand.
#
# As an example use, `tcpdump` can be used to capture packets to a pcap file:
#
#     sudo tcpdump -w example.pcap
#
# Output file can then be given to this script to print the decoded output:
#
#     ./pcap.py example.pcap
#
# An example output of this script is as follows:
# 
#     -- ETH Layer -- Tue Jun  5 10:52:34 2012 -- 54 bytes
#             src: 00:12:cf:e5:54:a0
#             dst: 00:1f:3c:23:db:d3
#             typ: 8
#             -- IP Layer --
#                     src: 192.168.10.226
#                     dst: 192.168.11.12
#                     typ: 6
#                     -- TCP Layer --
#                             src: 64332
#                             dst: 5888
#                             seq: 1492699879
#                             ack: 3729068838
#                             dat: b&apos;&apos;
#     -- ETH Layer -- Tue Jun  5 10:52:35 2012 -- 60 bytes
#             src: 00:1f:3c:23:db:d3
#             dst: 00:12:cf:e5:54:a0
#             typ: 8
#             -- IP Layer --
#                     src: 192.168.11.12
#                     dst: 192.168.10.226
#                     typ: 6
#                     -- TCP Layer --
#                             src: 5888
#                             dst: 64332
#                             seq: 3729068838
#                             ack: 1509477095
#                             dat: b&apos;\x00\x00\x00\x00\x00\x00&apos;
#
# Indentation follows packet levels so that you can utilize folding feature in
# your text editor to display packets at the desired level. Following settings
# are used for vim editor:
#
#     set foldmethod=indent
#     set foldenable
#     set foldlevel=0 &quot; only show packets
#     set foldlevel=1 &quot; decode ETH layer
#     set foldlevel=2 &quot; decode IP layer
#     set foldlevel=3 &quot; decode TCP layer
#
# You can also directly read from stdin as follows:
#
#     ./pcap example.pcap | vim -
#


import sys
import time
import struct

if len(sys.argv) &lt; 2:
    sys.stderr.write(&apos;usage: {} [PCAP_FILE]\n&apos;.format(sys.argv[0]))
    sys.exit(1)

def decode_eth(packet):
    src = struct.unpack(&apos;6B&apos;, packet[0:6])
    dst = struct.unpack(&apos;6B&apos;, packet[6:12])
    typ = struct.unpack(&apos;H&apos;, packet[12:14])[0]
    return src, dst, typ

def decode_ip(packet):
    typ = struct.unpack(&apos;B&apos;, packet[9:10])[0]
    src = struct.unpack(&apos;4B&apos;, packet[12:16])
    dst = struct.unpack(&apos;4B&apos;, packet[16:20])
    return src, dst, typ

def decode_tcp(packet):
    src = struct.unpack(&apos;H&apos;, packet[0:2])[0]
    dst = struct.unpack(&apos;H&apos;, packet[2:4])[0]
    seq = struct.unpack(&apos;I&apos;, packet[4:8])[0]
    ack = struct.unpack(&apos;I&apos;, packet[8:12])[0]
    return src, dst, seq, ack

with open(sys.argv[1], &apos;rb&apos;) as f:
    bom, major, minor, off, cap, typ = struct.unpack(&apos;IHHQII&apos;, f.read(24))
    if typ != 1:
        sys.stderr.write(&apos;error: only ethernet frame is supported\n&apos;)
        sys.exit(1)

    while True:
        header = f.read(16)
        if not header:
            break

        sec, msec, real, size = struct.unpack(&apos;IIII&apos;, header)
        print(&apos;-- ETH Layer --&apos;, time.ctime(sec), &apos;--&apos;, size, &apos;bytes&apos;)
        packet = f.read(size)

        eth_src, eth_dst, eth_typ = decode_eth(packet)
        print(&apos;\tsrc:&apos;, &apos;:&apos;.join(&quot;%02x&quot; % i for i in eth_src))
        print(&apos;\tdst:&apos;, &apos;:&apos;.join(&quot;%02x&quot; % i for i in eth_dst))
        print(&apos;\ttyp:&apos;, eth_typ)

        if eth_typ != 8:
            print(&apos;\t-- UNK Layer --&apos;)
            print(&apos;\t\tdat:&apos;, packet[14:])
            continue

        ip_src, ip_dst, ip_typ = decode_ip(packet[14:])
        print(&apos;\t-- IP Layer --&apos;)
        print(&apos;\t\tsrc:&apos;, &apos;.&apos;.join(str(i) for i in ip_src))
        print(&apos;\t\tdst:&apos;, &apos;.&apos;.join(str(i) for i in ip_dst))
        print(&apos;\t\ttyp:&apos;, ip_typ)

        if ip_typ != 6:
            print(&apos;\t\t-- UNK Layer --&apos;)
            print(&apos;\t\t\tdat:&apos;, packet[34:])
            continue

        tcp_src, tcp_dst, tcp_seq, tcp_ack = decode_tcp(packet[34:])
        print(&apos;\t\t-- TCP Layer --&apos;)
        print(&apos;\t\t\tsrc:&apos;, tcp_src)
        print(&apos;\t\t\tdst:&apos;, tcp_dst)
        print(&apos;\t\t\tseq:&apos;, tcp_seq)
        print(&apos;\t\t\tack:&apos;, tcp_ack)
        print(&apos;\t\t\tdat:&apos;, packet[54:])
</code></pre>

</body>

</html>
